ハッシュに興味を持ったFrankは、ハッシュアルゴリズムに、このようなアルゴリズムを考えた。
自然数の各桁を足した合計、それも二桁以上になる場合は、それを繰り返す。
つまり、
hash(4)=4,
hash(17)=hash(1+7)=hash(8)=8,
hash(119)=hash(1+1+9)=hash(11)=hash(2)=2のようになる。

しかし実際使ってみるとコリジョン（計算値がかぶってしまうこと）が多く、あまり使い物にならなかった。

それでも諦めきれないFrankに対して、あなたは「落ち着け、素数を数えるんだ」と言った。
やけになったFrankは、自然数 [K,N]　(K≤i≤N の範囲ということ） の中の連続した素数列で上記のハッシュアルゴリズムを使用し、コリジョンが起こらない（値がかぶらない）最大の範囲を考えようとしている。
言った手前、申し訳なくなったあなたは、Frankの代わりに求めてあげることにした。

範囲[K,N] (K≤i≤N の範囲)に含まれる連続した素数列で上記のハッシュアルゴリズムを使用した時に、
すべて異なる値になる最大の長さの素数列を求め、元の素数列の最初の素数を求めてください。
(複数同じ長さの素数列がある場合は、数が大きい方を選択する）

入力
K
N
1≤K≤N
2≤N≤200000
[K,N]の範囲に素数が含まれるのが保証されるものとする。
